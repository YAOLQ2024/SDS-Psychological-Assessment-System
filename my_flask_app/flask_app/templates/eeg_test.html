<!DOCTYPE html>
<html>
<head>
    <title>è„‘ç”µæ•°æ®æµæµ‹è¯•</title>
    <style>
        body { background: #000; color: #0f0; font-family: monospace; padding: 20px; }
        .log { background: #111; padding: 10px; margin: 10px 0; border: 1px solid #0f0; max-height: 400px; overflow-y: auto; }
        .error { color: #f00; }
        .success { color: #0ff; }
        canvas { border: 1px solid #0f0; background: #000; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>ğŸ§  è„‘ç”µæ•°æ®æµæµ‹è¯•é¡µé¢</h1>
    
    <h2>è¿æ¥çŠ¶æ€: <span id="status">æœªè¿æ¥</span></h2>
    
    <h3>å®æ—¶æ—¥å¿—:</h3>
    <div class="log" id="log"></div>
    
    <h3>æœ€æ–°æ•°æ®:</h3>
    <pre id="latest-data">ç­‰å¾…æ•°æ®...</pre>
    
    <h3>æ³¢å½¢å›¾:</h3>
    <canvas id="waveform" width="800" height="200"></canvas>
    
    <script>
        const log = document.getElementById('log');
        const statusEl = document.getElementById('status');
        const latestDataEl = document.getElementById('latest-data');
        const canvas = document.getElementById('waveform');
        const ctx = canvas.getContext('2d');
        
        let dataBuffer = [];
        
        function addLog(msg, type = 'info') {
            const time = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : (type === 'success' ? 'success' : '');
            log.innerHTML += `<div class="${className}">[${time}] ${msg}</div>`;
            log.scrollTop = log.scrollHeight;
        }
        
        // è¿æ¥åˆ° SSE æµ
        addLog('æ­£åœ¨è¿æ¥åˆ° /eeg/stream...');
        const eventSource = new EventSource('/eeg/stream');
        
        eventSource.onopen = () => {
            statusEl.textContent = 'âœ“ å·²è¿æ¥';
            statusEl.style.color = '#0f0';
            addLog('âœ“ SSE è¿æ¥å·²å»ºç«‹', 'success');
        };
        
        eventSource.onmessage = (event) => {
            try {
                const batch = JSON.parse(event.data);
                addLog(`æ”¶åˆ°æ•°æ®æ‰¹æ¬¡: ${batch.length} æ¡`, 'success');
                
                if (batch && batch.length > 0) {
                    batch.forEach(item => {
                        if (item.type === 'raw') {
                            dataBuffer.push(item.value);
                            if (dataBuffer.length > 500) dataBuffer.shift();
                        }
                    });
                    
                    // æ›´æ–°æœ€æ–°æ•°æ®æ˜¾ç¤º
                    const latest = batch[batch.length - 1];
                    latestDataEl.textContent = JSON.stringify(latest, null, 2);
                    
                    // ç»˜åˆ¶æ³¢å½¢
                    drawWaveform();
                }
            } catch (e) {
                addLog(`âœ— æ•°æ®è§£æé”™è¯¯: ${e.message}`, 'error');
                addLog(`åŸå§‹æ•°æ®: ${event.data}`, 'error');
            }
        };
        
        eventSource.onerror = (e) => {
            statusEl.textContent = 'âœ— è¿æ¥é”™è¯¯';
            statusEl.style.color = '#f00';
            addLog('âœ— SSE è¿æ¥é”™è¯¯', 'error');
        };
        
        function drawWaveform() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (dataBuffer.length < 2) return;
            
            ctx.beginPath();
            const step = canvas.width / dataBuffer.length;
            const centerY = canvas.height / 2;
            const scale = canvas.height / 100; // è°ƒæ•´ç¼©æ”¾
            
            dataBuffer.forEach((val, i) => {
                const x = i * step;
                const y = centerY - (val * scale);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸­å¿ƒçº¿
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
        }
        
        // å®šæœŸè½®è¯¢å†å²æ•°æ®ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        setInterval(() => {
            fetch('/eeg/history')
                .then(r => r.json())
                .then(d => {
                    if (d.success && d.data && d.data.values.length > 0) {
                        addLog(`è½®è¯¢è·å–åˆ° ${d.data.values.length} ä¸ªå†å²æ•°æ®ç‚¹`, 'success');
                        dataBuffer = d.data.values.slice(-500);
                        drawWaveform();
                    }
                })
                .catch(e => addLog(`è½®è¯¢å¤±è´¥: ${e.message}`, 'error'));
        }, 2000);
    </script>
</body>
</html>

